// Source: contracts/gateway/BaseAmplifierGateway.sol

pragma solidity ^0.8.0;

// SPDX-License-Identifier: MIT

// File contracts/interfaces/IAxelarGateway.sol

/**
 * @title IAxelarGateway
 * @dev Interface for the Axelar Gateway that supports general message passing and contract call execution.
 */
interface IAxelarGateway {
    /**
     * @notice Emitted when a contract call is made through the gateway.
     * @dev Logs the attempt to call a contract on another chain.
     * @param sender The address of the sender who initiated the contract call.
     * @param destinationChain The name of the destination chain.
     * @param destinationContractAddress The address of the contract on the destination chain.
     * @param payloadHash The keccak256 hash of the sent payload data.
     * @param payload The payload data used for the contract call.
     */
    event ContractCall(
        address indexed sender,
        string destinationChain,
        string destinationContractAddress,
        bytes32 indexed payloadHash,
        bytes payload
    );

    /**
     * @notice Sends a contract call to another chain.
     * @dev Initiates a cross-chain contract call through the gateway to the specified destination chain and contract.
     * @param destinationChain The name of the destination chain.
     * @param contractAddress The address of the contract on the destination chain.
     * @param payload The payload data to be used in the contract call.
     */
    function callContract(
        string calldata destinationChain,
        string calldata contractAddress,
        bytes calldata payload
    ) external;

    /**
     * @notice Checks if a contract call is approved.
     * @dev Determines whether a given contract call, identified by the commandId and payloadHash, is approved.
     * @param commandId The identifier of the command to check.
     * @param sourceChain The name of the source chain.
     * @param sourceAddress The address of the sender on the source chain.
     * @param contractAddress The address of the contract where the call will be executed.
     * @param payloadHash The keccak256 hash of the payload data.
     * @return True if the contract call is approved, false otherwise.
     */
    function isContractCallApproved(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view returns (bool);

    /**
     * @notice Validates and approves a contract call.
     * @dev Validates the given contract call information and marks it as approved if valid.
     * @param commandId The identifier of the command to validate.
     * @param sourceChain The name of the source chain.
     * @param sourceAddress The address of the sender on the source chain.
     * @param payloadHash The keccak256 hash of the payload data.
     * @return True if the contract call is validated and approved, false otherwise.
     */
    function validateContractCall(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash
    ) external returns (bool);

    /**
     * @notice Checks if a command has been executed.
     * @dev Determines whether a command, identified by the commandId, has been executed.
     * @param commandId The identifier of the command to check.
     * @return True if the command has been executed, false otherwise.
     */
    function isCommandExecuted(bytes32 commandId) external view returns (bool);
}

// File contracts/interfaces/IBaseAmplifierGateway.sol

/**
 * @title IBaseAmplifierGateway
 * @dev Interface for the Base Axelar Amplifier Gateway that supports cross-chain messaging.
 */
interface IBaseAmplifierGateway is IAxelarGateway {
    /**********\
    |* Errors *|
    \**********/

    error InvalidMessages();

    /**
     * @notice Emitted when a cross-chain message is approved.
     * @param commandId The identifier of the command to execute.
     * @param sourceChain The name of the source chain from whence the command came.
     * @param messageId The message id for the message.
     * @param sourceAddress The address of the sender on the source chain.
     * @param contractAddress The address of the contract where the call will be executed.
     * @param payloadHash The keccak256 hash of the approved payload data.
     */
    event MessageApproved(
        bytes32 indexed commandId,
        string sourceChain,
        string messageId,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash
    );

    /**
     * @notice Emitted when a message has been executed.
     * @dev Logs the execution of an approved message.
     * `sourceChain` and `messageId` aren't included in the event due to backwards compatibility with `validateContractCall`.
     * @param commandId The commandId for the message that was executed.
     */
    event MessageExecuted(bytes32 indexed commandId);

    /**
     * @notice Checks if a message is approved.
     * @dev Determines whether a given message, identified by the sourceChain and messageId, is approved.
     * @param sourceChain The name of the source chain.
     * @param messageId The unique identifier of the message.
     * @param sourceAddress The address of the sender on the source chain.
     * @param contractAddress The address of the contract where the call will be executed.
     * @param payloadHash The keccak256 hash of the payload data.
     * @return True if the contract call is approved, false otherwise.
     */
    function isMessageApproved(
        string calldata sourceChain,
        string calldata messageId,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view returns (bool);

    /**
     * @notice Checks if a message is executed.
     * @dev Determines whether a given message, identified by the sourceChain and messageId is executed.
     * @param sourceChain The name of the source chain.
     * @param messageId The unique identifier of the message.
     * @return True if the message is executed, false otherwise.
     */
    function isMessageExecuted(string calldata sourceChain, string calldata messageId) external view returns (bool);

    /**
     * @notice Validates if a message is approved. If message was in approved status, status is updated to executed to avoid replay.
     * @param sourceChain The name of the source chain.
     * @param messageId The unique identifier of the message.
     * @param sourceAddress The address of the sender on the source chain.
     * @param payloadHash The keccak256 hash of the payload data.
     * @return valid True if the message is approved, false otherwise.
     */
    function validateMessage(
        string calldata sourceChain,
        string calldata messageId,
        string calldata sourceAddress,
        bytes32 payloadHash
    ) external returns (bool valid);

    /**
     * @notice Compute the commandId for a message.
     * @param sourceChain The name of the source chain as registered on Axelar.
     * @param messageId The unique message id for the message.
     * @return The commandId for the message.
     */
    function messageToCommandId(string calldata sourceChain, string calldata messageId) external pure returns (bytes32);
}

// File contracts/types/AmplifierGatewayTypes.sol

/**
 * @notice This enum represents the different types of commands that can be processed by the Axelar Amplifier Gateway
 */
enum CommandType {
    ApproveMessages,
    RotateSigners
}

/**
 * @notice This struct represents a message that is to be processed by the Amplifier Gateway
 * @param sourceChain The chain from which the message originated
 * @param messageId The unique identifier for the message
 * @param sourceAddress The address from which the message originated
 * @param contractAddress The address of the contract that the message is intended for
 * @param payloadHash The hash of the payload that is to be processed
 */
struct Message {
    string sourceChain;
    string messageId;
    string sourceAddress;
    address contractAddress;
    bytes32 payloadHash;
}

// File contracts/gateway/BaseAmplifierGateway.sol

abstract contract BaseAmplifierGateway is IBaseAmplifierGateway {
    /// @dev This slot contains the storage for this contract in an upgrade-compatible manner
    /// keccak256('BaseAmplifierGateway.Slot') - 1;
    bytes32 internal constant BASE_AMPLIFIER_GATEWAY_SLOT =
        0x978b1ab9e384397ce0aab28eec0e3c25603b3210984045ad0e0f0a50d88cfc55;

    /// @dev Message can be in one of three states: non-existent, approved, or executed
    /// Non-existent: The message has not been seen before. Equal to 0
    /// Approved: The message has been seen and approved. Equal to keccak256 of the message data
    /// Executed: The message has been seen and executed. Equal to 1
    bytes32 internal constant MESSAGE_NONEXISTENT = 0;
    bytes32 internal constant MESSAGE_EXECUTED = bytes32(uint256(1));

    /// @dev Storage for this contract
    /// @param messages Mapping of commandId to message status
    struct BaseAmplifierGatewayStorage {
        mapping(bytes32 => bytes32) messages;
    }

    /******************\
    |* Public Methods *|
    \******************/

    /**
     * @notice Sends a message to the specified destination chain and address with a given payload.
     * This function is the entry point for general message passing between chains.
     * @param destinationChain The chain where the destination contract exists. A registered chain name on Axelar must be used here
     * @param destinationContractAddress The address of the contract to call on the destination chain
     * @param payload The payload to be sent to the destination contract
     */
    function callContract(
        string calldata destinationChain,
        string calldata destinationContractAddress,
        bytes calldata payload
    ) external {
        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);
    }

    /**
     * @notice Checks if a message is approved.
     * @dev Determines whether a given message, identified by the sourceChain and messageId, is approved.
     * @param sourceChain The name of the source chain.
     * @param messageId The unique identifier of the message.
     * @param sourceAddress The address of the sender on the source chain.
     * @param contractAddress The address of the contract where the call will be executed.
     * @param payloadHash The keccak256 hash of the payload data.
     * @return True if the contract call is approved, false otherwise.
     */
    function isMessageApproved(
        string calldata sourceChain,
        string calldata messageId,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view override returns (bool) {
        bytes32 commandId = messageToCommandId(sourceChain, messageId);
        return _isMessageApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
    }

    /**
     * @notice Checks if a message is executed.
     * @dev Determines whether a given message, identified by the sourceChain and messageId is executed.
     * @param sourceChain The name of the source chain.
     * @param messageId The unique identifier of the message.
     * @return True if the message is executed, false otherwise.
     */
    function isMessageExecuted(string calldata sourceChain, string calldata messageId) external view returns (bool) {
        return _baseAmplifierGatewayStorage().messages[messageToCommandId(sourceChain, messageId)] == MESSAGE_EXECUTED;
    }

    /**
     * @notice Validates if a message is approved. If message was in approved status, status is updated to executed to avoid replay.
     * @param sourceChain The name of the source chain.
     * @param messageId The unique identifier of the message.
     * @param sourceAddress The address of the sender on the source chain.
     * @param payloadHash The keccak256 hash of the payload data.
     * @return valid True if the message is approved, false otherwise.
     */
    function validateMessage(
        string calldata sourceChain,
        string calldata messageId,
        string calldata sourceAddress,
        bytes32 payloadHash
    ) external override returns (bool valid) {
        bytes32 commandId = messageToCommandId(sourceChain, messageId);
        valid = _validateMessage(commandId, sourceChain, sourceAddress, payloadHash);
    }

    /**
     * @notice Compute the commandId for a message.
     * @param sourceChain The name of the source chain as registered on Axelar.
     * @param messageId The unique message id for the message.
     * @return The commandId for the message.
     */
    function messageToCommandId(string calldata sourceChain, string calldata messageId) public pure returns (bytes32) {
        // Axelar doesn't allow `sourceChain` to contain '_', hence this encoding is umambiguous
        return keccak256(bytes(string.concat(sourceChain, '_', messageId)));
    }

    /*************************\
    |* Legacy Public Methods *|
    \*************************/

    /// @dev The below methods are available for backwards compatibility with the original AxelarExecutable
    /// Other implementations can skip these methods.

    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {
        return _baseAmplifierGatewayStorage().messages[commandId] != MESSAGE_NONEXISTENT;
    }

    function isContractCallApproved(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view override returns (bool) {
        return _isMessageApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
    }

    function validateContractCall(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash
    ) external override returns (bool valid) {
        valid = _validateMessage(commandId, sourceChain, sourceAddress, payloadHash);
    }

    /*************************\
    |* Integration Functions *|
    \*************************/

    /**
     * @notice Approves an array of messages.
     * @param  messages The array of messages to verify.
     */
    function _approveMessages(Message[] calldata messages) internal {
        uint256 length = messages.length;
        if (length == 0) revert InvalidMessages();

        for (uint256 i; i < length; ++i) {
            // Ignores message if it has already been approved before
            _approveMessage(messages[i]);
        }
    }

    /**********************\
    |* Internal Functions *|
    \**********************/

    function _isMessageApproved(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal view returns (bool) {
        bytes32 messageHash = _messageHash(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
        return _baseAmplifierGatewayStorage().messages[commandId] == messageHash;
    }

    /**
     * @dev For backwards compatibility with `validateContractCall`, `commandId` is used here instead of `messageId`.
     * @return valid True if message is valid
     */
    function _validateMessage(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash
    ) internal returns (bool valid) {
        bytes32 messageHash = _messageHash(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);
        valid = _baseAmplifierGatewayStorage().messages[commandId] == messageHash;

        if (valid) {
            _baseAmplifierGatewayStorage().messages[commandId] = MESSAGE_EXECUTED;

            emit MessageExecuted(commandId);
        }
    }

    /**
     * @dev Approves a message if it hasn't been approved before. The message status is set to approved.
     */
    function _approveMessage(Message calldata message) internal {
        // For other implementations, `sourceChain` and `messageId` tuple could be used as the mapping key directly.
        bytes32 commandId = messageToCommandId(message.sourceChain, message.messageId);

        // Ignore if message has already been approved/executed
        if (_baseAmplifierGatewayStorage().messages[commandId] != MESSAGE_NONEXISTENT) {
            return;
        }

        bytes32 messageHash = _messageHash(
            commandId,
            message.sourceChain,
            message.sourceAddress,
            message.contractAddress,
            message.payloadHash
        );
        _baseAmplifierGatewayStorage().messages[commandId] = messageHash;

        emit MessageApproved(
            commandId,
            message.sourceChain,
            message.messageId,
            message.sourceAddress,
            message.contractAddress,
            message.payloadHash
        );
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    /**
     * @dev For backwards compatibility with `validateContractCall`, `commandId` is used here instead of `messageId`.
     * @return bytes32 the message hash
     */
    function _messageHash(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal pure returns (bytes32) {
        return keccak256(abi.encode(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));
    }

    /**
     * @notice Gets the specific storage location for preventing upgrade collisions
     * @return slot containing the storage struct
     */
    function _baseAmplifierGatewayStorage() private pure returns (BaseAmplifierGatewayStorage storage slot) {
        assembly {
            slot.slot := BASE_AMPLIFIER_GATEWAY_SLOT
        }
    }
}
