// Source: contracts/interfaces/IAxelarAmplifierAuth.sol

pragma solidity ^0.8.0;

// SPDX-License-Identifier: MIT

// File contracts/types/WeightedMultisigTypes.sol

/**
 * @notice This struct represents the weighted signer
 * @param signer The address of the weighted signer
 * @param weight The weight of the weighted singer
 */
struct WeightedSigner {
    address signer;
    uint128 weight;
}

/**
 * @notice This struct represents the weighted signers payload
 * @param signers The list of weighted signers
 * @param threshold The threshold for the weighted signers
 * @param nonce The nonce to distinguish different weighted signer sets
 */
struct WeightedSigners {
    WeightedSigner[] signers;
    uint128 threshold;
    bytes32 nonce;
}

/**
 * @notice This struct represents a proof for a message from the weighted signers
 * @param signers The weighted signers
 * @param signatures The list of signatures
 */
struct Proof {
    WeightedSigners signers;
    bytes[] signatures;
}

// File contracts/interfaces/IAxelarAmplifierGatewayAuth.sol

interface IAxelarAmplifierGatewayAuth {
    /**
     * @notice This function takes messageHash and proof data and reverts if proof is invalid
     * @param dataHash The hash of the message that was signed
     * @param proof The data containing signers with signatures
     * @return isLatestSigners True if provided signers are the current ones
     */
    function validateProof(bytes32 dataHash, Proof calldata proof) external view returns (bool isLatestSigners);

    /**
     * @notice This function rotates the current signers with a new set
     * @param newSigners The data containing the new signers and their weights
     */
    function rotateSigners(WeightedSigners calldata newSigners) external;
}

// File contracts/interfaces/IBaseWeightedMultisig.sol

interface IBaseWeightedMultisig {
    error InvalidSigners();
    error InvalidThreshold();
    error MalformedSignatures();
    error LowSignaturesWeight();
    error InvalidWeights();
    error DuplicateSigners(bytes32 signersHash);
    error RedundantSignaturesProvided(uint256 required, uint256 provided);
    error InsufficientRotationDelay(uint256 minimumRotationDelay, uint256 lastRotationTimestamp, uint256 timeElapsed);

    event SignersRotated(uint256 indexed epoch, bytes32 indexed signersHash, bytes signers);

    /**
     * @dev This function returns the old signers retention period
     * @return uint256 The old signers retention period
     */
    function previousSignersRetention() external view returns (uint256);

    /**
     * @dev This function returns the current signers epoch
     * @return uint256 The current signers epoch
     */
    function epoch() external view returns (uint256);

    /**
     * @dev Returns the hash for a given signers epoch
     * @param signerEpoch The epoch to get the hash for
     * @return The hash for the given epoch
     */
    function signersHashByEpoch(uint256 signerEpoch) external view returns (bytes32);

    /**
     * @dev Returns the epoch for a given hash
     * @param signersHash The hash to get the epoch for
     * @return The epoch for the given hash
     */
    function epochBySignersHash(bytes32 signersHash) external view returns (uint256);

    /**
     * @notice This function returns the timestamp for the last signer rotation
     * @return uint256 The last rotation timestamp
     */
    function lastRotationTimestamp() external view returns (uint256);

    /**
     * @notice This function returns the time elapsed (in secs) since the last rotation
     * @return uint256 The time since the last rotation
     */
    function timeSinceRotation() external view returns (uint256);

    /**
     * @notice Compute the message hash that is signed by the weighted signers
     * @param signersHash The hash of the weighted signers that sign off on the data
     * @param dataHash The hash of the data
     * @return The message hash to be signed
     */
    function messageHashToSign(bytes32 signersHash, bytes32 dataHash) external view returns (bytes32);
}

// File contracts/interfaces/IAxelarAmplifierAuth.sol

/**
 * @title IAxelarAmplifierAuth Interface
 * @notice This interface defines the functions that the Axelar Amplifier Auth contract supports
 */
interface IAxelarAmplifierAuth is IBaseWeightedMultisig, IAxelarAmplifierGatewayAuth {

}
